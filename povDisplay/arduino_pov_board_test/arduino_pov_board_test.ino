#include <avr/interrupt.h>
#include <avr/pgmspace.h>

#define LOG_CYCLE_COUNTER 0 // LOG_CYCLE_COUNTER interfere avec la gestion temporelle de l'afficheur
#define COM_TRACE_LOG 0
#define COMM_DEBUG_LOG 0
#define COMM_INFO_LOG 0
#define LOG_ENABLED 0 //COMM_DEBUG_LOG || COMM_INFO_LOG || LOG_CYCLE_COUNTER

#define SLOW_DISPLAY_DRIVING_CLOCK 0
#define INTERUPT_ON_HALL_DETECTION 1
#define TIMER_MANAGEMENT 1

const int SERIAL_LATCH_COUNT = 5;

// Declare Pins
/*
Sur Arduino (ATmega328) : https://www.arduino.cc/en/Hacking/PinMapping168

DP 0-7   => PORTD 0-7
DP 8-13  => PORTB 0-5

DP 2     => INT0   
DP 3     => INT1

Pour gérer le display, nous avons besoin de 5 bits de Serial Data, 1 bit clock et 1 bit lock, donc 7 bits.
Idéalement, Pour gagner en temps d'execution, on peut manipuler les 7 bits avec un seul port (Generalement les ports on 8 bits).
Sur Arduino UNO il y a 3 ports accessibles :
PORTB: PB0 .. 5 => Digital Pin 8 .. 13 (PC13 pilote la LED)
PORTD: PD0 .. 7 => Digital Pin 0 .. 7 (PD0 & PD1 sont inutilisable à cause du RX/TX ; PD2 & PD3 sont les entrees d'interruption)
PORTC: PC0 .. 5 => Analog Pin 0 .. 5

Sur Arduino UNO, le seul port assez large le PORTD, on ne peut pas utiliser ni les pins RX & TX, et une entrée sera utilisée comme interruption. Donc le PORTD ne dispose que de 5 pins utilisable pour la communication du display.
=> Le display sera piloté sur le PORTB pour les Serial Data + Clock
PORTB => MSB [ CLOCK SD4 SD3 SD2 SD1 SD0 ] LSB
Envoyer 5 données en serie nécéssite ainsi 2 écriture sur le PORTB : 
PORTB = [ 0 SD4 SD3 SD2 SD1 SD0 ];
PORTB |= 32; 

PORTB0-4: Serial Data 0 à 4
PORTB5: CLOCK

PORTD3: Input HALL interrupt
PORTD4: Command TA => set: PORTD |= 0B10000; reset: PORTD &= 0B01111
PORTD5: Command TB => set: PORTD |= 0B100000; reset: PORTD &= 0B011111
PORTD6: LOCK => set: PORTD |= 0B1000000; reset: PORTD &= 0B0111111

*/

/* ############################################################################################# */
/* ############################################################################################# */
/* ############################################################################################# */
/* ########################################## PINS CONFIG ###################################### */
/* ############################################################################################# */
/* ############################################################################################# */
/* ############################################################################################# */


// PINS are expressed in "Arduino value"
const int HALL_SENSOR_PIN = 3; // Attention ici on utilise le pin arduino uno 3

const int A_COMMAND_PIN = 4;
const int B_COMMAND_PIN = 5;

const int CLOCK_PIN = 13;
const int LOCK_PIN = 6;

const int SERIAL_DATA_0_PIN = 8;
const int SERIAL_DATA_1_PIN = 9;
const int SERIAL_DATA_2_PIN = 10;
const int SERIAL_DATA_3_PIN = 11;
const int SERIAL_DATA_4_PIN = 12;
const int SERIAL_DATA_PINS[SERIAL_LATCH_COUNT] = {SERIAL_DATA_0_PIN, SERIAL_DATA_1_PIN, SERIAL_DATA_2_PIN, SERIAL_DATA_3_PIN, SERIAL_DATA_4_PIN};

/* ############################################################################################# */
/* ############################################################################################# */
/* ############################################################################################# */
/* ########################################## PICTURES ######################################### */
/* ############################################################################################# */
/* ############################################################################################# */
/* ############################################################################################# */

const byte LABOMEDIA_LOGO[2048] PROGMEM = {28, 28, 28, 28, 24, 24, 24, 24, 28, 28, 28, 24, 24, 24, 24, 24, 28, 28, 28, 24, 24, 24, 24, 24, 28, 28, 24, 24, 24, 24, 24, 24, 28, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 16, 24, 24, 24, 24, 16, 16, 16, 16, 24, 24, 24, 24, 24, 16, 16, 16, 24, 24, 24, 24, 16, 16, 16, 16, 24, 24, 24, 16, 16, 16, 16, 16, 24, 24, 16, 16, 16, 16, 16, 16, 24, 24, 16, 16, 16, 16, 16, 16, 24, 24, 16, 16, 16, 16, 16, 16, 24, 24, 16, 16, 16, 16, 16, 16, 24, 16, 16, 16, 16, 16, 16, 16, 24, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 0, 16, 16, 16, 16, 16, 16, 0, 0, 16, 16, 16, 16, 16, 16, 0, 0, 16, 16, 16, 16, 16, 16, 0, 0, 16, 16, 16, 16, 16, 16, 0, 0, 16, 16, 16, 16, 16, 16, 0, 0, 16, 16, 16, 16, 16, 16, 16, 0, 16, 16, 16, 16, 16, 16, 16, 0, 16, 16, 16, 16, 16, 16, 16, 0, 16, 16, 16, 16, 16, 16, 16, 0, 16, 16, 16, 16, 16, 16, 16, 0, 16, 16, 16, 16, 16, 16, 16, 0, 16, 16, 16, 16, 16, 16, 16, 0, 16, 16, 16, 16, 16, 16, 0, 0, 16, 16, 16, 16, 16, 16, 0, 0, 16, 16, 16, 16, 16, 16, 0, 0, 16, 16, 16, 16, 16, 16, 0, 0, 16, 16, 16, 16, 16, 16, 0, 0, 16, 16, 16, 16, 16, 16, 0, 0, 16, 16, 16, 16, 16, 0, 0, 0, 16, 16, 16, 16, 16, 0, 0, 0, 16, 16, 16, 16, 16, 0, 0, 0, 16, 16, 16, 16, 16, 0, 0, 0, 16, 16, 16, 16, 0, 0, 0, 0, 16, 16, 16, 16, 0, 0, 0, 0, 16, 16, 16, 16, 0, 0, 0, 0, 16, 16, 16, 16, 0, 16, 0, 0, 16, 16, 16, 16, 16, 16, 16, 0, 24, 24, 16, 16, 16, 16, 16, 16, 24, 24, 24, 24, 24, 16, 16, 16, 24, 24, 24, 24, 24, 24, 16, 16, 28, 24, 24, 24, 24, 24, 24, 24, 28, 28, 24, 24, 24, 24, 24, 24, 28, 28, 24, 24, 24, 24, 24, 24, 28, 28, 28, 24, 24, 24, 24, 24, 28, 28, 28, 28, 28, 24, 24, 24, 28, 28, 28, 28, 28, 28, 24, 24, 28, 28, 28, 28, 28, 28, 28, 24, 28, 28, 28, 28, 28, 28, 28, 24, 30, 28, 28, 28, 28, 28, 28, 28, 30, 30, 28, 28, 28, 28, 28, 28, 30, 30, 28, 28, 28, 28, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 24, 28, 28, 28, 28, 28, 28, 28, 24, 28, 28, 28, 28, 28, 24, 24, 24, 28, 28, 28, 28, 24, 24, 24, 24, 28, 28, 28, 28, 24, 24, 24, 24, 28, 28, 24, 24, 24, 24, 24, 24, 28, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 16, 24, 24, 24, 24, 24, 24, 16, 16, 24, 24, 24, 16, 16, 16, 16, 16, 24, 16, 16, 16, 16, 16, 16, 0, 16, 16, 16, 16, 16, 16, 0, 0, 16, 16, 16, 16, 16, 16, 0, 0, 16, 16, 16, 16, 16, 16, 16, 0, 16, 16, 16, 16, 16, 16, 0, 0, 16, 16, 16, 16, 16, 16, 16, 0, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 24, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 24, 16, 16, 16, 16, 16, 16, 16, 24, 16, 16, 16, 16, 16, 16, 16, 24, 16, 16, 16, 16, 16, 16, 16, 24, 24, 16, 16, 16, 16, 16, 16, 24, 24, 16, 16, 16, 16, 16, 16, 24, 24, 16, 16, 16, 16, 16, 16, 24, 16, 16, 16, 16, 16, 16, 16, 24, 16, 16, 16, 16, 16, 16, 16, 24, 24, 16, 16, 16, 16, 16, 16, 24, 24, 16, 16, 16, 16, 16, 16, 24, 24, 16, 16, 16, 16, 16, 16, 24, 16, 16, 16, 16, 16, 16, 16, 24, 16, 16, 16, 16, 16, 16, 16, 24, 16, 16, 16, 16, 16, 16, 16, 24, 16, 16, 16, 16, 16, 16, 16, 24, 16, 16, 16, 16, 16, 16, 16, 24, 16, 16, 16, 16, 16, 16, 16, 24, 16, 16, 16, 16, 16, 16, 16, 24, 24, 16, 16, 16, 16, 16, 16, 24, 24, 16, 16, 16, 16, 16, 16, 24, 24, 24, 16, 16, 16, 16, 16, 24, 24, 24, 16, 16, 16, 16, 16, 24, 24, 24, 16, 16, 16, 16, 16, 24, 24, 24, 24, 16, 16, 16, 16, 24, 24, 24, 24, 16, 16, 16, 16, 24, 24, 24, 24, 16, 16, 16, 16, 24, 24, 24, 24, 24, 16, 16, 16, 24, 24, 24, 24, 24, 16, 16, 16, 24, 24, 24, 24, 24, 16, 16, 16, 24, 24, 24, 24, 24, 16, 16, 16, 24, 24, 24, 24, 24, 16, 16, 16, 24, 24, 24, 24, 24, 24, 24, 16, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 28, 24, 24, 24, 24, 24, 24, 24, 28, 28, 24, 24, 24, 24, 24, 24, 28, 28, 28, 24, 24, 24, 24, 24, 28, 28, 28, 24, 24, 24, 24, 24, 28, 28, 28, 28, 24, 24, 24, 24, 28, 28, 28, 28, 24, 24, 24, 24, 28, 28, 28, 28, 24, 24, 24, 24, 28, 28, 28, 28, 28, 24, 24, 24, 28, 28, 28, 28, 28, 24, 24, 24, 28, 28, 28, 28, 28, 28, 24, 24, 28, 28, 28, 28, 28, 28, 24, 24, 28, 28, 28, 28, 28, 28, 28, 24, 28, 28, 28, 28, 28, 28, 28, 24, 28, 28, 28, 28, 28, 28, 28, 24, 28, 28, 28, 28, 28, 28, 28, 24, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 30, 30, 28, 28, 28, 28, 28, 28, 30, 30, 28, 28, 28, 28, 28, 28, 30, 30, 28, 28, 28, 28, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 30, 30, 28, 28, 28, 28, 28, 28, 30, 30, 28, 28, 28, 28, 28, 28, 14, 30, 28, 28, 28, 28, 28, 28, 14, 30, 28, 28, 28, 28, 28, 28, 30, 30, 28, 28, 28, 28, 28, 28, 30, 30, 28, 28, 28, 28, 28, 28, 30, 30, 28, 28, 28, 28, 28, 28, 14, 14, 28, 28, 28, 28, 28, 28, 30, 14, 12, 28, 28, 28, 28, 28, 30, 30, 12, 12, 28, 28, 28, 28, 14, 22, 28, 12, 12, 28, 28, 28, 6, 6, 20, 28, 12, 12, 28, 28, 22, 6, 12, 12, 12, 28, 12, 12, 30, 30, 12, 12, 28, 12, 12, 12, 30, 14, 28, 28, 12, 12, 12, 12, 6, 30, 28, 12, 12, 12, 28, 28, 22, 14, 12, 12, 12, 28, 28, 28, 30, 22, 12, 28, 28, 28, 28, 28, 30, 22, 4, 28, 28, 28, 28, 28, 30, 28, 20, 12, 28, 28, 28, 28, 22, 20, 28, 28, 12, 28, 28, 28, 30, 28, 28, 28, 12, 28, 12, 12, 30, 28, 28, 28, 28, 12, 12, 28, 30, 20, 20, 20, 20, 28, 28, 28, 22, 20, 28, 28, 20, 28, 28, 12, 28, 28, 28, 28, 20, 20, 28, 8, 28, 28, 28, 28, 28, 20, 12, 12, 28, 28, 28, 28, 28, 20, 28, 8, 28, 28, 28, 28, 28, 20, 28, 8, 28, 28, 28, 28, 28, 28, 20, 8, 20, 28, 28, 28, 28, 28, 24, 24, 20, 20, 28, 20, 20, 20, 24, 24, 28, 20, 20, 28, 28, 24, 24, 24, 28, 28, 28, 28, 28, 28, 24, 24, 28, 28, 28, 28, 28, 16, 16, 16, 28, 20, 20, 20, 20, 16, 16, 16, 28, 28, 28, 28, 24, 24, 24, 16, 28, 28, 28, 28, 24, 24, 24, 16, 28, 28, 28, 24, 24, 24, 24, 16, 28, 28, 24, 24, 24, 24, 24, 16, 28, 28, 24, 24, 24, 24, 24, 16, 28, 16, 16, 16, 16, 16, 16, 16, 28, 28, 24, 24, 24, 24, 24, 16, 28, 28, 24, 24, 24, 24, 24, 16, 28, 28, 28, 24, 24, 24, 24, 16, 28, 28, 28, 28, 24, 24, 24, 16, 28, 28, 28, 28, 24, 24, 24, 16, 28, 20, 20, 20, 20, 16, 16, 16, 28, 28, 28, 28, 28, 16, 16, 16, 28, 28, 28, 28, 28, 28, 24, 24, 20, 20, 20, 28, 28, 24, 24, 24, 20, 28, 28, 20, 20, 20, 20, 24, 20, 28, 28, 20, 28, 28, 20, 24, 28, 28, 20, 20, 28, 28, 20, 8, 28, 28, 20, 28, 28, 20, 28, 12, 28, 28, 20, 28, 28, 20, 28, 12, 30, 28, 20, 28, 28, 20, 28, 28, 28, 20, 28, 28, 20, 20, 28, 28, 30, 28, 20, 20, 20, 28, 28, 28, 30, 28, 20, 20, 20, 28, 12, 28, 22, 28, 28, 28, 28, 12, 28, 12, 22, 20, 28, 28, 12, 28, 28, 28, 30, 28, 28, 28, 12, 28, 28, 28, 30, 28, 20, 12, 28, 28, 28, 28, 30, 22, 4, 28, 28, 28, 28, 28, 30, 22, 12, 28, 28, 28, 28, 28, 22, 30, 28, 12, 12, 28, 28, 28, 6, 14, 12, 28, 12, 12, 28, 28, 30, 14, 12, 12, 28, 28, 12, 12, 14, 30, 12, 12, 12, 28, 28, 12, 6, 22, 28, 12, 12, 12, 28, 28, 14, 6, 20, 28, 28, 12, 28, 12, 6, 30, 28, 28, 28, 28, 12, 12, 30, 30, 12, 12, 28, 28, 28, 12, 30, 14, 14, 28, 28, 28, 28, 28, 14, 14, 30, 28, 28, 28, 28, 28, 30, 30, 28, 28, 28, 28, 28, 28, 30, 30, 30, 28, 28, 28, 28, 28, 30, 30, 30, 28, 28, 28, 28, 28, 30, 30, 28, 28, 28, 28, 28, 28, 30, 30, 30, 28, 28, 28, 28, 28, 30, 30, 30, 28, 28, 28, 28, 28, 30, 30, 28, 28, 28, 28, 28, 28, 30, 30, 28, 28, 28, 28, 28, 28, 30, 30, 28, 28, 28, 28, 28, 28, 30, 30, 28, 28, 28, 28, 28, 28, 30, 30, 28, 28, 28, 28, 28, 28, 30, 30, 28, 28, 28, 28, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 24, 28, 28, 28, 28, 28, 28, 28, 24, 28, 28, 28, 28, 28, 28, 28, 24, 28, 28, 28, 28, 28, 28, 28, 24, 28, 28, 28, 28, 28, 28, 28, 24, 28, 28, 28, 28, 28, 28, 28, 24, 28, 28, 28, 28, 28, 28, 24, 24, 28, 28, 28, 28, 28, 28, 24, 24, 28, 28, 28, 28, 28, 24, 24, 24, 28, 28, 28, 28, 28, 24, 24, 24, };
const byte AMIPO_LOGO[2048] PROGMEM = {31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 30, 30, 29, 29, 29, 29, 29, 29, 28, 30, 29, 29, 29, 29, 29, 25, 28, 28, 29, 29, 29, 29, 29, 25, 28, 28, 29, 29, 29, 29, 25, 25, 28, 28, 28, 29, 29, 25, 25, 25, 28, 28, 28, 29, 29, 25, 25, 25, 28, 28, 28, 29, 25, 25, 25, 25, 28, 28, 24, 25, 25, 25, 25, 25, 28, 28, 24, 25, 25, 25, 25, 25, 28, 28, 24, 24, 25, 25, 25, 25, 28, 24, 24, 24, 24, 25, 25, 25, 28, 24, 24, 24, 24, 25, 25, 25, 24, 24, 24, 24, 25, 25, 25, 17, 24, 24, 24, 24, 25, 25, 25, 17, 24, 24, 24, 24, 25, 25, 25, 17, 24, 24, 24, 24, 24, 25, 17, 17, 24, 24, 24, 24, 24, 17, 17, 17, 24, 24, 24, 24, 16, 17, 17, 17, 24, 24, 24, 24, 16, 17, 17, 17, 24, 26, 24, 24, 16, 17, 17, 17, 26, 26, 26, 16, 16, 17, 16, 17, 26, 26, 26, 26, 16, 21, 20, 21, 26, 26, 26, 18, 16, 21, 20, 21, 26, 26, 26, 18, 20, 20, 20, 21, 26, 26, 18, 18, 20, 20, 20, 20, 26, 18, 18, 22, 20, 20, 20, 20, 26, 18, 18, 22, 20, 20, 20, 20, 26, 18, 22, 22, 20, 20, 20, 20, 18, 18, 22, 20, 20, 20, 20, 20, 26, 22, 22, 20, 20, 20, 20, 20, 18, 18, 20, 20, 20, 20, 20, 20, 18, 22, 20, 20, 20, 20, 20, 20, 22, 20, 20, 20, 20, 20, 20, 20, 22, 20, 20, 20, 20, 20, 20, 4, 20, 20, 20, 20, 20, 20, 20, 4, 20, 20, 20, 20, 20, 20, 4, 12, 20, 20, 20, 20, 20, 20, 4, 8, 20, 20, 20, 20, 20, 4, 0, 8, 20, 20, 20, 20, 20, 0, 8, 8, 20, 20, 20, 20, 16, 0, 8, 8, 20, 20, 20, 16, 0, 8, 8, 8, 20, 20, 16, 16, 0, 0, 8, 8, 20, 16, 16, 16, 0, 8, 8, 8, 16, 16, 16, 16, 0, 8, 8, 8, 16, 16, 16, 16, 0, 8, 8, 8, 16, 16, 16, 0, 8, 8, 8, 0, 16, 16, 16, 0, 8, 8, 8, 0, 16, 16, 0, 0, 8, 8, 8, 0, 16, 16, 0, 8, 8, 8, 8, 0, 16, 16, 0, 8, 8, 8, 8, 0, 16, 16, 8, 8, 8, 8, 10, 8, 17, 16, 0, 8, 8, 10, 10, 8, 21, 16, 0, 8, 10, 10, 10, 10, 21, 20, 8, 8, 8, 10, 10, 10, 21, 1, 8, 8, 10, 10, 10, 10, 21, 5, 8, 10, 10, 10, 10, 10, 21, 21, 0, 10, 10, 10, 10, 10, 21, 5, 2, 10, 10, 10, 10, 10, 21, 5, 10, 10, 10, 10, 10, 10, 21, 1, 10, 10, 10, 10, 10, 10, 21, 1, 10, 10, 10, 10, 10, 10, 21, 3, 11, 10, 10, 10, 10, 10, 21, 3, 11, 10, 10, 10, 10, 10, 21, 3, 11, 10, 10, 10, 10, 10, 21, 3, 11, 10, 10, 10, 10, 10, 21, 3, 11, 10, 10, 10, 10, 10, 21, 1, 11, 10, 10, 10, 10, 10, 21, 1, 11, 10, 10, 10, 10, 10, 21, 21, 2, 10, 10, 10, 10, 10, 21, 5, 10, 10, 10, 10, 10, 10, 21, 1, 8, 10, 10, 10, 10, 10, 21, 17, 8, 10, 10, 10, 10, 10, 21, 21, 0, 10, 10, 10, 10, 10, 21, 21, 0, 8, 10, 10, 10, 10, 21, 20, 8, 8, 10, 10, 10, 10, 21, 20, 0, 8, 10, 10, 10, 10, 21, 20, 0, 8, 8, 10, 10, 8, 20, 20, 4, 0, 8, 8, 10, 8, 20, 20, 20, 8, 8, 8, 8, 8, 20, 20, 4, 4, 8, 8, 8, 8, 20, 20, 20, 4, 8, 8, 8, 8, 20, 20, 20, 20, 8, 8, 8, 8, 20, 20, 20, 20, 4, 8, 8, 8, 20, 20, 20, 20, 4, 8, 8, 8, 20, 20, 20, 20, 4, 8, 8, 8, 20, 20, 20, 20, 20, 4, 8, 8, 20, 20, 20, 20, 4, 4, 12, 8, 20, 20, 20, 20, 20, 4, 12, 8, 20, 20, 20, 20, 20, 4, 12, 8, 20, 20, 20, 20, 20, 20, 4, 12, 20, 20, 20, 20, 20, 20, 4, 12, 22, 20, 20, 20, 20, 20, 4, 4, 22, 20, 20, 20, 20, 20, 20, 4, 22, 22, 20, 20, 20, 20, 20, 4, 18, 22, 20, 20, 20, 20, 20, 20, 18, 22, 22, 20, 20, 20, 20, 20, 18, 18, 22, 20, 22, 20, 20, 20, 18, 18, 22, 22, 22, 20, 20, 20, 26, 18, 18, 22, 22, 20, 20, 20, 26, 18, 18, 22, 22, 22, 22, 20, 26, 18, 18, 18, 22, 22, 22, 20, 27, 18, 18, 18, 22, 22, 22, 20, 27, 26, 18, 18, 18, 22, 22, 22, 27, 26, 26, 18, 18, 22, 22, 22, 27, 26, 26, 19, 18, 18, 22, 22, 27, 26, 27, 27, 19, 18, 23, 22, 27, 27, 27, 27, 19, 18, 23, 22, 27, 27, 27, 27, 19, 18, 19, 22, 27, 27, 27, 27, 27, 19, 19, 18, 27, 27, 27, 27, 27, 19, 19, 19, 27, 27, 27, 27, 27, 27, 19, 19, 25, 27, 27, 27, 27, 27, 19, 19, 25, 27, 27, 27, 27, 27, 19, 19, 25, 25, 27, 27, 27, 27, 19, 19, 25, 25, 27, 27, 27, 27, 27, 27, 25, 25, 27, 27, 27, 27, 27, 27, 25, 25, 27, 27, 27, 27, 27, 27, 25, 25, 25, 25, 27, 27, 27, 27, 25, 25, 25, 25, 25, 27, 27, 27, 29, 29, 25, 25, 25, 27, 27, 27, 29, 29, 25, 25, 25, 27, 27, 27, 29, 29, 25, 25, 25, 27, 27, 27, 29, 29, 25, 25, 25, 27, 27, 27, 29, 29, 29, 25, 25, 25, 27, 27, 29, 29, 29, 25, 25, 25, 27, 27, 29, 29, 29, 25, 25, 25, 25, 27, 29, 29, 29, 29, 25, 25, 25, 27, 29, 29, 29, 29, 29, 25, 25, 27, 28, 29, 29, 29, 29, 25, 25, 25, 28, 29, 29, 29, 29, 29, 25, 25, 28, 29, 29, 29, 29, 29, 25, 25, 28, 29, 29, 29, 29, 29, 25, 25, 28, 28, 29, 29, 29, 29, 25, 25, 28, 28, 29, 29, 29, 29, 29, 25, 28, 28, 29, 29, 29, 29, 29, 25, 28, 28, 29, 29, 29, 29, 29, 25, 28, 28, 28, 29, 29, 29, 29, 25, 28, 28, 28, 29, 29, 29, 29, 29, 28, 28, 28, 29, 29, 29, 29, 29, 30, 28, 29, 29, 29, 29, 29, 29, 30, 28, 28, 29, 29, 29, 29, 29, 30, 28, 28, 29, 29, 29, 29, 29, 30, 28, 28, 29, 29, 29, 29, 29, 30, 28, 28, 29, 29, 29, 29, 29, 30, 30, 28, 29, 29, 29, 29, 29, 30, 30, 28, 29, 29, 29, 29, 29, 30, 30, 28, 28, 29, 29, 29, 29, 30, 30, 28, 28, 29, 29, 29, 29, 30, 30, 28, 28, 29, 29, 29, 29, 30, 30, 28, 21, 29, 29, 29, 29, 30, 30, 22, 20, 29, 29, 29, 29, 30, 22, 22, 20, 21, 29, 29, 29, 30, 22, 22, 20, 21, 21, 29, 29, 30, 22, 22, 20, 21, 21, 29, 29, 30, 22, 22, 20, 21, 21, 21, 29, 22, 22, 22, 22, 21, 21, 21, 21, 22, 22, 22, 22, 21, 21, 21, 29, 22, 22, 22, 22, 21, 21, 21, 21, 18, 22, 22, 22, 21, 21, 21, 5, 22, 22, 22, 22, 20, 21, 21, 5, 22, 22, 22, 22, 20, 21, 5, 5, 18, 22, 22, 22, 20, 21, 5, 5, 22, 22, 22, 22, 20, 5, 5, 5, 18, 22, 22, 22, 20, 21, 5, 5, 18, 22, 22, 22, 21, 5, 5, 5, 18, 22, 22, 22, 21, 5, 5, 5, 18, 22, 22, 22, 5, 5, 5, 5, 18, 18, 22, 6, 4, 5, 5, 5, 18, 22, 22, 20, 4, 5, 5, 5, 18, 22, 22, 22, 5, 5, 5, 5, 18, 22, 22, 4, 5, 5, 5, 5, 18, 22, 22, 20, 5, 5, 5, 5, 22, 22, 20, 4, 5, 5, 5, 5, 18, 22, 4, 4, 5, 5, 5, 5, 22, 22, 20, 4, 5, 5, 5, 5, 22, 22, 4, 4, 5, 5, 5, 5, 22, 22, 4, 5, 5, 5, 5, 13, 22, 20, 4, 5, 5, 5, 5, 13, 20, 20, 4, 4, 5, 5, 13, 13, 20, 20, 4, 4, 5, 5, 13, 13, 20, 20, 4, 5, 5, 13, 13, 9, 20, 20, 4, 5, 9, 9, 9, 9, 20, 20, 4, 5, 13, 9, 9, 9, 20, 4, 12, 9, 9, 9, 9, 9, 16, 16, 8, 9, 9, 9, 9, 1, 16, 16, 1, 1, 1, 1, 1, 1, 16, 0, 1, 1, 1, 1, 1, 1, 16, 0, 1, 1, 1, 1, 1, 1, 16, 0, 1, 1, 1, 1, 1, 1, 16, 1, 1, 1, 1, 1, 1, 1, 16, 1, 1, 1, 1, 1, 1, 1, 16, 1, 1, 1, 1, 1, 1, 1, 17, 1, 1, 1, 1, 1, 3, 3, 17, 1, 1, 1, 1, 1, 3, 3, 17, 1, 1, 1, 3, 3, 3, 3, 17, 17, 1, 1, 3, 3, 3, 3, 17, 19, 3, 15, 15, 15, 11, 3, 23, 7, 7, 7, 7, 15, 15, 15, 23, 23, 7, 7, 15, 15, 15, 15, 23, 23, 7, 7, 7, 7, 15, 15, 23, 23, 7, 7, 7, 7, 7, 15, 23, 23, 7, 7, 7, 7, 7, 15, 23, 23, 7, 7, 7, 7, 7, 7, 23, 23, 7, 7, 7, 7, 7, 15, 23, 23, 7, 7, 7, 7, 7, 7, 23, 23, 7, 7, 7, 7, 7, 7, 19, 23, 23, 7, 7, 7, 7, 7, 19, 23, 7, 7, 7, 7, 7, 7, 19, 19, 23, 7, 7, 7, 7, 7, 19, 19, 23, 23, 7, 7, 7, 7, 19, 19, 23, 23, 7, 7, 7, 7, 19, 19, 23, 23, 7, 7, 7, 7, 19, 19, 23, 23, 7, 7, 7, 7, 19, 19, 23, 7, 7, 7, 7, 7, 19, 19, 23, 23, 7, 7, 7, 7, 19, 19, 23, 23, 23, 7, 7, 7, 19, 23, 23, 23, 23, 7, 7, 7, 19, 23, 23, 23, 23, 23, 7, 7, 19, 19, 23, 23, 23, 7, 7, 7, 19, 23, 23, 23, 23, 23, 7, 7, 23, 23, 23, 23, 23, 23, 7, 7, 19, 23, 23, 23, 23, 23, 23, 7, 19, 23, 23, 23, 23, 23, 23, 7, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 31, 23, 23, 23, 23, 23, 23, 31, 31, 23, 23, 23, 23, 23, 23, 31, 31, 31, 23, 23, 23, 23, 31, 31, 31, 31, 23, 23, 23, 31, 31, 31, 31, 31, 23, 23, 31, 31, 31, 31, 31, 31, 31, 23, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, };
const byte TRIANGLE[2048] PROGMEM = {29, 31, 31, 27, 27, 27, 27, 27, 29, 31, 31, 31, 27, 27, 27, 27, 29, 31, 31, 31, 27, 27, 27, 27, 29, 31, 31, 31, 27, 27, 27, 27, 29, 29, 31, 31, 27, 27, 27, 27, 29, 29, 31, 31, 31, 27, 27, 27, 29, 29, 31, 31, 31, 27, 27, 27, 29, 29, 31, 31, 31, 27, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 27, 27, 27, 29, 29, 31, 31, 31, 27, 27, 27, 29, 29, 31, 31, 31, 27, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 31, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 31, 31, 31, 31, 27, 27, 29, 29, 31, 31, 31, 31, 27, 27, 29, 29, 31, 31, 31, 27, 27, 27, 29, 29, 31, 31, 31, 27, 27, 27, 29, 29, 31, 31, 31, 27, 27, 27, 29, 31, 31, 31, 31, 27, 27, 27, 29, 31, 31, 31, 27, 27, 27, 27, 29, 31, 31, 31, 27, 27, 27, 27, 29, 31, 31, 31, 27, 27, 27, 27, 29, 31, 31, 27, 27, 27, 27, 27, 31, 31, 31, 27, 27, 27, 27, 27, 31, 31, 31, 27, 27, 27, 27, 27, 31, 31, 27, 27, 27, 27, 27, 27, 31, 31, 27, 27, 27, 27, 27, 31, 31, 31, 27, 27, 27, 27, 27, 31, 31, 27, 27, 27, 27, 27, 27, 31, 31, 27, 27, 27, 27, 27, 31, 31, 27, 27, 27, 27, 27, 27, 31, 31, 27, 27, 27, 27, 27, 27, 31, 23, 27, 27, 27, 27, 27, 31, 31, 23, 27, 27, 27, 27, 31, 31, 23, 23, 27, 27, 27, 27, 31, 31, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 31, 23, 23, 23, 27, 27, 31, 23, 23, 23, 23, 23, 27, 27, 31, 23, 23, 23, 23, 23, 31, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 7, 23, 23, 23, 23, 23, 23, 23, 15, 23, 23, 23, 23, 23, 23, 7, 15, 23, 23, 23, 23, 7, 15, 15, 15, 23, 23, 7, 15, 15, 15, 15, 15, 23, 7, 7, 15, 15, 15, 15, 15, 23, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 31, 15, 15, 15, 15, 15, 15, 31, 31, 15, 15, 15, 15, 15, 15, 15, 31, 23, 15, 15, 15, 15, 15, 15, 15, 23, 7, 7, 15, 15, 15, 15, 15, 23, 23, 7, 15, 15, 15, 15, 15, 23, 23, 23, 23, 7, 15, 15, 15, 23, 23, 23, 23, 23, 23, 7, 15, 23, 23, 23, 23, 23, 23, 23, 15, 23, 23, 23, 23, 23, 23, 23, 7, 31, 23, 23, 23, 23, 23, 23, 23, 27, 27, 31, 23, 23, 23, 23, 23, 27, 27, 31, 23, 23, 23, 23, 23, 27, 27, 27, 31, 31, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 27, 31, 31, 23, 23, 27, 27, 27, 27, 31, 31, 23, 23, 27, 27, 27, 27, 27, 31, 31, 23, 27, 27, 27, 27, 27, 27, 31, 23, 27, 27, 27, 27, 27, 27, 31, 31, 31, 27, 27, 27, 27, 27, 31, 31, 31, 27, 27, 27, 27, 27, 27, 31, 31, 31, 27, 27, 27, 27, 27, 31, 31, 31, 27, 27, 27, 27, 27, 31, 31, 31, 27, 27, 27, 27, 27, 27, 31, 31, 31, 27, 27, 27, 27, 27, 31, 31, 31, 27, 27, 27, 27, 27, 29, 31, 31, 27, 27, 27, 27, 27, 29, 31, 31, 31, 27, 27, 27, 27, 29, 31, 31, 31, 27, 27, 27, 27, 29, 31, 31, 31, 27, 27, 27, 27, 29, 31, 31, 31, 31, 27, 27, 27, 29, 29, 31, 31, 31, 27, 27, 27, 29, 29, 31, 31, 31, 27, 27, 27, 29, 29, 31, 31, 31, 27, 27, 27, 29, 29, 31, 31, 31, 31, 27, 27, 29, 29, 31, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 31, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 31, 31, 31, 27, 27, 27, 29, 29, 31, 31, 31, 27, 27, 27, 29, 29, 29, 31, 31, 27, 27, 27, 29, 29, 29, 31, 31, 31, 27, 27, 29, 29, 31, 31, 31, 27, 27, 27, 29, 29, 31, 31, 31, 27, 27, 27, 29, 29, 31, 31, 31, 27, 27, 27, 29, 29, 31, 31, 27, 27, 27, 27, 29, 31, 31, 31, 27, 27, 27, 27, 29, 31, 31, 31, 27, 27, 27, 27, 29, 31, 31, 31, 27, 27, 27, 27, 29, 31, 31, 27, 27, 27, 27, 27, 31, 31, 31, 27, 27, 27, 27, 27, 31, 31, 31, 27, 27, 27, 27, 27, 31, 31, 27, 27, 27, 27, 27, 27, 31, 31, 27, 27, 27, 27, 27, 27, 31, 31, 27, 27, 27, 27, 27, 31, 31, 27, 27, 27, 27, 27, 27, 31, 31, 27, 27, 27, 27, 27, 27, 31, 27, 27, 27, 27, 27, 27, 27, 23, 27, 27, 27, 27, 27, 31, 31, 23, 27, 27, 27, 27, 27, 31, 23, 23, 27, 27, 27, 27, 31, 31, 23, 23, 27, 27, 27, 27, 31, 31, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 31, 31, 23, 23, 23, 23, 27, 27, 31, 23, 23, 23, 23, 23, 27, 23, 23, 23, 23, 23, 23, 23, 27, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 15, 23, 23, 23, 23, 23, 23, 7, 15, 23, 23, 23, 23, 31, 15, 15, 15, 23, 23, 23, 23, 15, 15, 15, 15, 23, 23, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 31, 15, 15, 15, 15, 15, 15, 15, 31, 31, 15, 15, 15, 15, 31, 31, 31, 31, 31, 15, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 15, 31, 31, 31, 31, 31, 31, 31, 15, 31, 31, 31, 31, 31, 31, 31, 15, 15, 31, 31, 31, 31, 31, 31, 15, 15, 31, 31, 31, 31, 31, 31, 15, 15, 15, 31, 31, 31, 31, 31, 15, 15, 15, 31, 31, 31, 31, 31, 15, 15, 15, 15, 31, 31, 31, 31, 15, 15, 15, 15, 31, 31, 31, 31, 15, 15, 15, 15, 31, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 15, 31, 31, 31, 15, 15, 15, 15, 31, 31, 31, 31, 15, 15, 15, 15, 31, 31, 31, 31, 15, 15, 15, 15, 31, 31, 31, 31, 15, 15, 15, 31, 31, 31, 31, 31, 15, 15, 15, 31, 31, 31, 31, 31, 15, 15, 31, 31, 31, 31, 31, 31, 15, 15, 31, 31, 31, 31, 31, 31, 15, 31, 31, 31, 31, 31, 31, 31, 15, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 15, 31, 31, 31, 31, 31, 31, 15, 15, 15, 15, 31, 31, 31, 31, 15, 15, 15, 15, 15, 15, 31, 31, 15, 15, 15, 15, 15, 15, 31, 15, 15, 15, 15, 15, 15, 15, 15, 15, 23, 23, 15, 15, 15, 15, 15, 15, 23, 23, 23, 23, 15, 15, 15, 15, 23, 23, 23, 23, 31, 15, 15, 15, 23, 23, 23, 23, 23, 23, 7, 15, 23, 23, 23, 23, 23, 23, 23, 15, 27, 23, 23, 23, 23, 23, 23, 23, 27, 23, 23, 23, 23, 23, 23, 23, 27, 27, 31, 23, 23, 23, 23, 23, 27, 27, 31, 31, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 27, 31, 31, 23, 23, 27, 27, 27, 27, 31, 31, 23, 23, 27, 27, 27, 27, 27, 31, 23, 23, 27, 27, 27, 27, 27, 31, 31, 23, 27, 27, 27, 27, 27, 27, 27, 23, 31, 27, 27, 27, 27, 27, 27, 31, 31, 27, 27, 27, 27, 27, 27, 31, 31, 31, 27, 27, 27, 27, 27, 31, 31, 31, 27, 27, 27, 27, 27, 27, 31, 31, 27, 27, 27, 27, 27, 27, 31, 31, 31, 27, 27, 27, 27, 27, 31, 31, 31, 27, 27, 27, 27, 27, };
const byte CERCLE[2048] PROGMEM = {27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 19, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 31, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 19, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 19, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 31, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 31, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 19, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 31, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 31, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 19, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 19, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 31, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 31, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 27, 23, 23, 23, 23, 27, 27, 27, 23, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, 27, 27, 27, 31, 23, 23, 23, 23, };

const byte* const PICTURES[] PROGMEM = { CERCLE, TRIANGLE, LABOMEDIA_LOGO, AMIPO_LOGO };

/* ############################################################################################# */
/* ############################################################################################# */
/* ############################################################################################# */
/* ###################################### CONFIG / CONSTANTS ################################### */
/* ############################################################################################# */
/* ############################################################################################# */
/* ############################################################################################# */

const int DISPLAY_BYTE_COUNT = SERIAL_LATCH_COUNT;
const byte TIMER0_MIN_VALUE = 1;
const unsigned int TIMER1_MIN_VALUE = 256 * TIMER0_MIN_VALUE;
static byte STARTING_TRANSPOSED_DISPLAY[8] = {0, 31, 31, 31, 31, 31, 31, 31};

/* ############################################################################################# */
/* ############################################################################################# */
/* ############################################################################################# */
/* ########################################## STATES ########################################### */
/* ############################################################################################# */
/* ############################################################################################# */
/* ############################################################################################# */

/*
  Old (first) Data structure : X bytes to send.
  Most Significant Bit of each byte is BOTTOM most, so, with the led horizontal, the center (or bottom) to the left, a line is displayed like it is written in the byte array.
  A Byte Buffer is implemented with a Byte array.
  
*/

// Legacy buffer
//byte _oneLineMemory[DISPLAY_BYTE_COUNT] = {0xAA, 0xAA, 0xAA, 0xAA, 0xAA};
byte _oneLineMemory[DISPLAY_BYTE_COUNT] = {0x77, 0x77, 0x77, 0x77, 0x77};

//byte _byteBufferToDisplay[DISPLAY_BYTE_COUNT];
byte _transposedByteBufferToDisplay[8] = {0, 31, 31, 31, 31, 31, 31, 31}; // Used to buffer transposed data to send to display

// States in used for the display
volatile byte _displayLapCounter = 0; // byte pour économiser des cycles
volatile byte _displayEventPosition = 0; // Only 256 angular positions
volatile unsigned int _previousTimer1Position = 0;
byte _transposeWork[DISPLAY_BYTE_COUNT] = {0, 0, 0, 0, 0}; // Used to transpose Datas
// Display buffer is the buffer that should be displayed.
//byte _displayBuffer[8][8] = {{31, 31, 31, 31, 31, 31, 31, 31}, {31, 31, 31, 31, 31, 31, 31, 31}, {31, 31, 31, 31, 31, 31, 31, 31}, {31, 31, 31, 31, 31, 31, 31, 31}, {31, 31, 31, 31, 31, 31, 31, 31}, {31, 31, 31, 31, 31, 31, 31, 31}, {31, 31, 31, 31, 31, 31, 31, 31}, {31, 31, 31, 31, 31, 31, 31, 31}};
byte _displayBuffer[8] = {31, 31, 31, 31, 31, 31, 31, 31};
volatile byte _displayedPictureIndex = 0;
unsigned int _currentLevel = 1;

// Cycle counter
unsigned int _cycleCounterStart = 0;
unsigned int _cycleCounterFinish = 0;

/* ############################################################################################# */
/* ############################################################################################# */
/* ############################################################################################# */
/* ########################################## FUNCTIONS ######################################## */
/* ############################################################################################# */
/* ############################################################################################# */
/* ############################################################################################# */

void quickSelectLedCurrent(byte level) {

  // Note : A call on this method will not necessarely change the value of outputs, does it consume clock cycle necessarely ?
  switch(level) {
    case 3:
      // Current TA + TB
      PORTD &= 0B11001111;
      break;
    case 2:
      // Current TA
      PORTD |= 0B00100000; // Switch off before lighting on
      PORTD &= 0B11101111; 
      break;
    case 1:
      // Current TB
      PORTD |= 0B00010000;
      PORTD &= 0B11011111; // Switch off before lighting on
      break;
    default:
      // No Current TA an TB HIGH
      PORTD |= 0B00110000;
      break;
  }
}

/*
  55 cycles to send informations.
*/
void quickSendTransposedByteBufferToSerialLatch(byte byteArray[]) {
  // The for loop consume +39 extra cycle with i of type byte.
  /*
  for(byte i = 0; i < 8; i ++) {    
    // Lecture des 5bits à envoyés
    #if COMM_TRACE_LOG == 1
    Serial.println(serialDatas);
    #endif

    // Push serialDatas on PORTB
    PORTB = byteArray[i];
    // Send clock rising edge
    PORTB |= 0B00100000;
  }
  */

  PORTB = byteArray[0];
  PORTB |= 0B00100000;
  PORTB = byteArray[1];
  PORTB |= 0B00100000;
  PORTB = byteArray[2];
  PORTB |= 0B00100000;
  PORTB = byteArray[3];
  PORTB |= 0B00100000;
  PORTB = byteArray[4];
  PORTB |= 0B00100000;
  PORTB = byteArray[5];
  PORTB |= 0B00100000;
  PORTB = byteArray[6];
  PORTB |= 0B00100000;
  PORTB = byteArray[7];
  PORTB |= 0B00100000;

  // Send lock rising edge
  PORTD |= 0B01000000;
  
  // Lower Lock ?
  PORTD &= 0B10111111;
}

/*
  Ici le reset de TNCT1L consomme enormement de cycles. Donc pour ne pas le reset et ne pas perdre trop de précisions (avoir un meilleur arrondi), je stock la valeur précédente du timer dans _previousTimer1Position.
  Ceci passe la conso de la méthode de 31 cycles à 43. 57 cycles avec abs(), je ne suis pas sur d'en avoir besoin.
  +2 cycles pour l'appel de oneLapEvent().
*/
void hallDisplayInterrupt() {
  // Protection against too short interval between hall interrupt.
  /*
  if (TCNT1 < TIMER1_MIN_VALUE) {
    return;
  }
  */
  // Change Timer0 interrupt compare value
  //OCR0A = TCNT1H;
  /*
  if (TCNT1H < TIMER0_MIN_VALUE) {
    OCR0A = TIMER0_MIN_VALUE; // Set timer 0 interrupt compare match to TCNT1H. TCNT1H are 8 MSB of Timer1 value. => Divide by 256.
  } else {
    
  }
  */
  
  // At last reset Timer1
  //TCNT1H = 0;
  //TCNT1L = 0; // This operation is really slow. several thousands clock cycles.
 
  
  byte interval = (abs(TCNT1 - _previousTimer1Position)) >> 8;
  if (interval < TIMER0_MIN_VALUE) {
    return;
  }
  _previousTimer1Position = TCNT1;
  if (interval < TIMER0_MIN_VALUE) { // Theroically 1 stand for 1024 cycles by step which should be ok.
    OCR0A = TIMER0_MIN_VALUE; // Set timer 0 interrupt compare match to TCNT1H. TCNT1H are 8 MSB of Timer1 value. => Divide by 256.
  } else {
    OCR0A = interval;
  }
  
  
  // Reset Timer0
  TCNT0 = 0;
  
  #if COMM_INFO_LOG == 1
  Serial.print("Timer1 value: ");
  Serial.print(TCNT1);
  Serial.print(" ; TCNT1H: ");
  Serial.print(TCNT1H);
  Serial.print(" ; _displayLapCounter: ");
  Serial.print(_displayLapCounter);
  Serial.print(" ; _displayEventPosition: ");
  Serial.print(_displayEventPosition);
  Serial.println("");
  #endif
 

  _displayLapCounter += 1;
  _displayEventPosition = 200;
  
  oneLapEvent(_displayLapCounter);
}

/*
  13 cycles 
  + 4 cycles pour l'appel de oneStepEvent() empty.
*/
void nextPositionDisplayInterrupt() {
    // No need to reset timer we configred it to reset on compare match.
  _displayEventPosition ++;
  
  oneStepEvent(_displayLapCounter, _displayEventPosition);
}

// Timer0 compare interrupt service routine
SIGNAL(TIMER0_COMPA_vect) {
  nextPositionDisplayInterrupt();
}

/*
Load a byte array from FLASH memory (PROGMEM) into SRAM.
The read must be paginated to reduce impact on SRAM.
The supplied byteBuffer need to be of the supplied pageSize.

Read biggest pasges is more efficient in clock cycles :
119 cycles to read 8 bytes (15 cycles per byte)
638 cycles to read 64 bytes (10 cycles per byte)
*/
void loadFlashByteArrayToSram(const byte pictureAddress[], byte byteBuffer[], int pageSize, int pageNumber) {
  memcpy_P(byteBuffer, pictureAddress + pageSize * pageNumber, pageSize);
}

void loadPictureToSram(byte pictureIndex, byte byteBuffer[], int pageSize, int pageNumber) {
  memcpy_P(byteBuffer, PICTURES[pictureIndex] + pageSize * pageNumber, pageSize);
}

// the setup function runs once when you press reset or power the board
void setup() {
    
  // Initialize ouptuts
  digitalWrite(A_COMMAND_PIN, HIGH);
  digitalWrite(B_COMMAND_PIN, HIGH);
  
  digitalWrite(CLOCK_PIN, LOW);
  digitalWrite(LOCK_PIN, LOW);

  // Config outputs
  pinMode(A_COMMAND_PIN, OUTPUT);
  pinMode(B_COMMAND_PIN, OUTPUT);
  
  pinMode(CLOCK_PIN, OUTPUT);
  pinMode(LOCK_PIN, OUTPUT);
  
  for(int k = 0; k < SERIAL_LATCH_COUNT; k ++) {
    pinMode(SERIAL_DATA_PINS[k], OUTPUT);
  }
  
  // Config inputs
  pinMode(HALL_SENSOR_PIN, INPUT_PULLUP);
  
  // Config interrupts
  #if INTERUPT_ON_HALL_DETECTION == 1
  attachInterrupt(HALL_SENSOR_PIN - 2, hallDisplayInterrupt, RISING); // I should use digitalPinToInterrupt(), but where is it declared ?
  #endif

  #if TIMER_MANAGEMENT == 1
  // Init display rotation timer (Timer1 16 bits)
  TCCR1A = 0;
  TCCR1B = 5; // Prescaler: CLK / 1024
 
  // Init compare timer  (Timer0 8 bits)
  TCCR0A = 0;
  TCCR0A |= (1 << WGM01); // Reset timer on compare match
  TCCR0B = 5; // Prescaler: CLK / 1024 => 256 interrupt by cycle
  TIMSK0 = 0;
  TIMSK0 |= (1 << OCIE0A); // enable timer compare interrupt on channel A
  OCR0A = 255;
  //TIMSK0 |= _BV(OCIE0A);
  #endif 
  
  // Set Timer 1 to normal mode at F_CPU.
  #if LOG_CYCLE_COUNTER == 1
  TCCR1A = 0;
  TCCR1B = 1;
  #endif

  // Initialize serial communication
  #if LOG_ENABLED == 1
  Serial.begin(115200);
  Serial.println("Log enabled !");
  #endif

  //testKeyFunctionsCycleCounts();
  
  //Init display
  quickSendTransposedByteBufferToSerialLatch(STARTING_TRANSPOSED_DISPLAY);
  quickSelectLedCurrent(1);

}

// This function is called when the display round the clock.
void oneLapEvent(byte lapCount) {
  //rightRotateByteBuffer(_transposedByteBufferToDisplay, 8);
  // Don't works, unable to call quickSelectLedCurrent with a global variable.
  /*
  if ((lapCount % 32) == 31) {
    //_displayedPictureIndex = (_displayedPictureIndex + 1) % sizeof(PICTURES);
    _currentLevel ++;
    _currentLevel = _currentLevel % 4;
    
    quickSelectLedCurrent((byte) _currentLevel);
  }
  */
}

// This function is called when the display is one step further.
void oneStepEvent(byte lapCount, byte displayPosition) {
  sendPictureStepMemoryToDisplay(displayPosition);
  //oneStepEvent_testSyncBarsWithoutPictures(lapCount, displayPosition);
}

// the loop function runs over and over again forever
void loop() {


}

void preloadMemory() {
  // Maybe ?
}

void sendPictureStepMemoryToDisplay(int displayPosition) {
  loadFlashByteArrayToSram(PICTURES[2], _transposedByteBufferToDisplay, 8, displayPosition);
  //loadPictureToSram(_displayedPictureIndex, _transposedByteBufferToDisplay, 8, displayPosition);
  quickSendTransposedByteBufferToSerialLatch(_transposedByteBufferToDisplay);
  //logByteBuffer(_transposedByteBufferToDisplay, 8);
}

/* ############################################################################################# */
/* ############################################################################################# */
/* ############################################################################################# */
/* ########################################## TESTS ############################################ */
/* ############################################################################################# */
/* ############################################################################################# */
/* ############################################################################################# */

void loop_testDisplayWithoutSync() {
  //selectLedCurrent(1);
  
  /*
  Serial.print("TCNT0 : ");
  Serial.print(TCNT0);
  Serial.print(" ; OCR0A : ");
  Serial.println(OCR0A);
  */
  
  /*
  // Copy line memory to working buffer
  memcpy(byteBufferToDisplay, _oneLineMemory, DISPLAY_BYTE_COUNT);
  // Complement working buffer because 0 is needed to light a LED
  complementByteBuffer(_byteBufferToDisplay, DISPLAY_BYTE_COUNT);
  
  // Send the working buffer to the serial latches
  sendByteBufferToSerialLatch(_byteBufferToDisplay);
  
  // Rotate the memory
  //leftRotateByteBuffer(_oneLineMemory, DISPLAY_BYTE_COUNT);
  rightRotateByteBuffer(_oneLineMemory, DISPLAY_BYTE_COUNT);
  */
  
  //rightRotateByteBuffer(_oneLineMemory, DISPLAY_BYTE_COUNT);
  //logByteBuffer(_oneLineMemory, DISPLAY_BYTE_COUNT);
  //logByteBuffer(_transposedByteBufferToDisplay, 8);

  //memcpy(_byteBufferToDisplay, _oneLineMemory, DISPLAY_BYTE_COUNT);
  //complementByteBuffer(_byteBufferToDisplay, DISPLAY_BYTE_COUNT);  
  

  
  
  //for (int k = 0; k < 0xFF; k++) {
  //  delay(1);
  //}
}

void oneStepEvent_testSyncBarsWithoutPictures(int lapCount, int displayPosition) {
  // Division par 128 environ
  
  if (displayPosition % 2 != 0) { //lapCount % 256
    quickSelectLedCurrent(0);
    return;
  }
  
  #if COMM_DEBUG_LOG == 1
  Serial.println("Timer0 compare matched.");
  #endif
  
  //rightRotateByteBuffer(_oneLineMemory, DISPLAY_BYTE_COUNT);
  quickSendTransposedByteBufferToSerialLatch(_transposedByteBufferToDisplay);
  //quickSelectLedCurrent(1);
    
  // Swap TB
  PORTD ^= 0B00100000; // biwise XOR 
}

void testKeyFunctionsCycleCounts() {
  
  Serial.print("quickSelectLedCurrent ");
  startCycleCounter();
  
  quickSelectLedCurrent(1);
  
  stopCycleCounter();
  
  Serial.print("quickSendTransposedByteBufferToSerialLatch ");
  startCycleCounter();
  
  quickSendTransposedByteBufferToSerialLatch(STARTING_TRANSPOSED_DISPLAY);
  
  stopCycleCounter();
  /*
  Serial.print("sendBufferToDisplay ");
  startCycleCounter();
  
  sendBufferToDisplay(5);
  
  stopCycleCounter();
  */
  Serial.print("loadFlashByteArrayToSram 8 bytes ");
  byte foo8[8];
  startCycleCounter();
  
  loadFlashByteArrayToSram(LABOMEDIA_LOGO, foo8, 8, 12);
  
  stopCycleCounter();
    
  Serial.print("loadFlashByteArrayToSram 32 bytes ");
  byte foo32[32];
  startCycleCounter();
  
  loadFlashByteArrayToSram(LABOMEDIA_LOGO, foo32, 32, 12);
  
  stopCycleCounter();
    
  Serial.print("loadFlashByteArrayToSram 64 bytes ");
  byte foo64[64];
  startCycleCounter();
  
  loadFlashByteArrayToSram(LABOMEDIA_LOGO, foo64, 64, 12);
  
  stopCycleCounter();
  
  Serial.print("nextPositionDisplayInterrupt ");
  startCycleCounter();
  
  nextPositionDisplayInterrupt();
  
  stopCycleCounter();
  
  Serial.print("hallDisplayInterrupt ");
  startCycleCounter();
  
  hallDisplayInterrupt();
  
  stopCycleCounter();
  
  
}

/* ############################################################################################# */
/* ############################################################################################# */
/* ############################################################################################# */
/* ########################################## TOOLS ############################################ */
/* ############################################################################################# */
/* ############################################################################################# */
/* ############################################################################################# */

void transposeByteBuffer(byte byteBuffer[], byte result[]) {
  
  #if LOG_CYCLE_COUNTER == 1
  Serial.print("transposeByteBuffer ");
  startCycleCounter();
  #endif
  
  // Copy byteBuffer to work
  memcpy(_transposeWork, byteBuffer, DISPLAY_BYTE_COUNT);
  
  byte byteBufferToDisplay[DISPLAY_BYTE_COUNT];
  for(int i = 0; i < 8; i ++) {
    result[i] = 0;
    int power = 8;
    for(int k = 0; k < DISPLAY_BYTE_COUNT; k ++) {
      result[i] += (_transposeWork[k] & 0x80) / power;
      //Serial.println(power);
      _transposeWork[k] = _transposeWork[k] << 1;
      power = power << 1;
    }
  }
  
  #if LOG_CYCLE_COUNTER == 1
  stopCycleCounter();
  #endif
}

// Right shift all bits of a byte buffer
void rightShiftByteBuffer(byte byteArray[], int bufferSize) {
  // first shift right most, then put LSB from left byte to MSB on right most byte ...
  byteArray[bufferSize - 1] = byteArray[bufferSize - 1] >> 1;
  for(int k = bufferSize - 2; k >= 0; k --) {
    bitWrite(byteArray[k + 1], 7, bitRead(byteArray[k], 0));
    byteArray[k] = byteArray[k] >> 1;
  }
}

void leftShiftByteBuffer(byte byteArray[], int bufferSize) {
  byteArray[0] = byteArray[0] << 1;
  for(int k = 1; k < bufferSize; k ++) {
    bitWrite(byteArray[k - 1], 0, bitRead(byteArray[k], 7));
    byteArray[k] = byteArray[k] << 1;
  }
}

void rightRotateByteBuffer(byte byteArray[], int bufferSize) {
  boolean mem = bitRead(byteArray[bufferSize - 1], 0);
  rightShiftByteBuffer(byteArray, bufferSize);
  bitWrite(byteArray[0], 7, mem);
}

void leftRotateByteBuffer(byte byteArray[], int bufferSize) {
  boolean mem = bitRead(byteArray[0], 7);
  leftShiftByteBuffer(byteArray, bufferSize);
  bitWrite(byteArray[bufferSize - 1], 0, mem);  
}

// Complement all bits of a byte array into a new byte array.
void complementByteBuffer(byte byteArray[], int bufferSize) {
  for (int k = 0; k < bufferSize; k++) {
    byteArray[k] = 255 - byteArray[k];
  }
}

void startCycleCounter() {
  #if LOG_CYCLE_COUNTER == 1
  cli(); // Same as noInterrupts()
  _cycleCounterStart = TCNT1;
  #endif
}

void stopCycleCounter() {
  #if LOG_CYCLE_COUNTER == 1
  _cycleCounterFinish = TCNT1;
  sei(); // Same as interrupts()
  int overhead = 24;
  long cyclesCount = _cycleCounterFinish - _cycleCounterStart - overhead;
  Serial.print("took ");
  Serial.print(cyclesCount);
  Serial.print(" CPU cycles (");
  Serial.print(_cycleCounterFinish);
  Serial.print(" - ");
  Serial.print(_cycleCounterStart);
  Serial.print(" - ");
  Serial.print(overhead);
  Serial.print(")\n\n");
  delay(10);
  #endif
}

void logByteBuffer(byte byteBuffer[], int length) {
  #if LOG_ENABLED == 1
  for(int k=0; k< length; k++) {
    Serial.print(byteBuffer[k]);
    Serial.print(" ");
    
  }
  Serial.println("");
  #endif
}

void logPicture(const byte pictureAddress[]) {
  #if LOG_ENABLED == 1
  for (int i = 0; i < 32; i++) {
    for (int j = 0; j < 64; j++) {
       Serial.print(pgm_read_byte_near(pictureAddress + i*64 + j));
       Serial.print(", ");
    }
    Serial.println("");
  }
  Serial.println("");
  #endif
}

/* ############################################################################################# */
/* ############################################################################################# */
/* ############################################################################################# */
/* ########################################## USELESS ########################################## */
/* ############################################################################################# */
/* ############################################################################################# */
/* ############################################################################################# */


// Send one bit of information on a serial latch
void sendBitToSerialLatch(boolean data, int canal) {
  digitalWrite(canal, data);
  //delay(1);

  clockSerialLatches();
}

// Clock all serial latches
void clockSerialLatches() {
  #if COMM_DEBUG_LOG == 1
  Serial.print("Clock !\n");
  #endif
  
  // Clock on rising edge
  digitalWrite(CLOCK_PIN, LOW);
    
  #if SLOW_DISPLAY_DRIVING_CLOCK == 1
  delay(1);
  #endif
  
  digitalWrite(CLOCK_PIN, HIGH);
}

// Lock all serial latches
void lockSerialLatches() {
  #if COMM_DEBUG_LOG == 1
  Serial.print("Lock !\n");
  #endif
  
  // Lock on rising edge
  digitalWrite(LOCK_PIN, LOW);
    
  #if SLOW_DISPLAY_DRIVING_CLOCK == 1
  delay(1);
  #endif
  
  digitalWrite(LOCK_PIN, HIGH);
}

// Send one complete byte of information on a serial latch
void sendByteToSerialLatch(byte data, int canal) {
  //Serial.print("Sent vals: ");
  for (int i = 7; i >= 0; i --) {
    boolean val = bitRead(data, i);
    sendBitToSerialLatch(val, canal);
    //Serial.print(val);
  }
  //Serial.print("\n");  
}

// From 0 to 3: 0 mean no current => LEDs OFF ; 3 mean full current, both // resistors supplying current.
void selectLedCurrent(int level) {
  // Note : A call on this method will not necessarely change the value of outputs, does it consume clock cycle necessarely ?
  switch(level) {
    case 3:
      //Serial.print("Current level 3\n");
      digitalWrite(A_COMMAND_PIN, LOW);
      digitalWrite(B_COMMAND_PIN, LOW);
      break;
    case 2:
      //Serial.print("Current level 2\n");
      digitalWrite(A_COMMAND_PIN, HIGH);
      digitalWrite(B_COMMAND_PIN, LOW);
      break;
    case 1:
      //Serial.print("Current level 1\n");
      digitalWrite(A_COMMAND_PIN, LOW);
      digitalWrite(B_COMMAND_PIN, HIGH);
      break;
    default:
      //Serial.print("Current level 0\n");
      digitalWrite(A_COMMAND_PIN, HIGH);
      digitalWrite(B_COMMAND_PIN, HIGH);
      break;
  }
}


/*
  This function is responsible to send data on serial latches. It will be called by interrupt and should be as fast a possible.
*/
void sendByteBufferToSerialLatch(byte byteArray[]) {
  #if LOG_CYCLE_COUNTER == 1
  Serial.print("testCycleCounterShouldBe0 ");
  delay(10);
  startCycleCounter();
  stopCycleCounter();
  
  Serial.print("sendByteArrayToSerialLatch ");
  startCycleCounter();
  #endif
  
  // The for loop should consume extra cycle clock than hardcoded shifting.
  // Idem for the multiple latch management. A loop symplify the code, but it should consume extra clock cycles.
  // An alternative is to use shiftOut to shift a byte bit per bit cf https://www.arduino.cc/reference/en/language/functions/advanced-io/shiftout/
  for(int i = 0; i < 8; i ++) {
    
    #if COMM_DEBUG_LOG == 1
    Serial.print("Send Byte Buffer:\n");
    Serial.print(bitRead(byteArray[0], i));
    Serial.print(" ");
    Serial.print(bitRead(byteArray[1], i));
    Serial.print(" ");
    Serial.print(bitRead(byteArray[2], i));
    Serial.print(" ");
    Serial.print(bitRead(byteArray[3], i));
    Serial.print(" ");
    Serial.print(bitRead(byteArray[4], i));
    Serial.print("\n");
    #endif
    
    
    // Output a bit on each latches in SERIAL_DATA_PINS array => La boucle consomme 440 cycles de plus que le hardcode.
    for(int k = 0; k < DISPLAY_BYTE_COUNT; k++) {
      digitalWrite(SERIAL_DATA_PINS[k], bitRead(byteArray[k], i));
      //PORTB |= 0x02; 
    }

    clockSerialLatches();
  }
  
  lockSerialLatches();
  
  #if LOG_CYCLE_COUNTER == 1
  stopCycleCounter();
  #endif
}


void testCycleCounter() {
  #if LOG_CYCLE_COUNTER == 1
  cli(); // Same as noInterrupts()
  int cycleCounterTestStart = TCNT0;
  int cycleCounterTestFinish = TCNT0;
  sei();
  
  long difference = cycleCounterTestFinish - cycleCounterTestStart;

  Serial.print("Test cycle counter : Start = ");
  Serial.print(cycleCounterTestStart);
  Serial.print(" ; Stop = ");
  Serial.print(cycleCounterTestFinish);
  Serial.print("; Difference = ");
  Serial.println(difference);
  
  #endif
}


// Called on Hall detection
void hallCounterInterrupt() {
  _displayLapCounter += 1;
  
  #if COMM_INFO_LOG == 1
  Serial.print("Hall detected (");
  Serial.print(_displayLapCounter);
  Serial.println(")");
  #endif
  
  // Rotate the memory
  //leftRotateByteBuffer(oneLineMemory, DISPLAY_BYTE_COUNT);
  //rightRotateByteBuffer(oneLineMemory, DISPLAY_BYTE_COUNT);
  
  
  for (int k = 0; k < 400; k++) {
    selectLedCurrent(3);
  }
  
  selectLedCurrent(0);
  
}

void loadPicture2(byte byteBuffer[8][8], int index) {

  /*
  Notes :
  Enbiron 130 cycles pour copier 1 octet parmis 1 avec memcpy dans bytebuffer.
  Environ 400 cycles pour copier 8 octets parmis 64 avec memcpy dans bytebuffer.
  Environ 800 cycles pour copier 64 octets parmis 64 avec memcpy dans bytebuffer.
  Environ 1600 cycles pour copier 128 octets parmis 128 avec memcpy dans bytebuffer.
  Environ 3200 cycles pour copier 8 octets parmis 512 avec memcpy dans bytebuffer.
  Environ 3600 cycles pour copier 64 octets parmis 512 avec memcpy dans bytebuffer.
  
  Idées :
  Charger en SRAM des morceaux de 64 bytes => 400 cycles.
  On charge les 64 premiers bytes, puis on précharge les 64 suivants dans la loop en tache de fond.
  Dés que l'on a plus besoin de 64 premiers bytes, on passe au 64 suivants déjà préchargés et on lance le préchargement de 64 nouveaux.
  
  Du coup il faut définir des blocs de 64 bytes à initialiser en SRAM lors du préchargement.
  Pour une image de 256 * 8 bytes, il faut donc 32 blocs de 64 bytes.
  
  Meilleur alternative : utiliser PROGMEM pour stocker les données en FLASH (mémoire programme).
  */
  
  
  #if LOG_CYCLE_COUNTER == 1
  Serial.print("test ");
  startCycleCounter();
  stopCycleCounter();
  
  Serial.print("load8bytesInSram ");
  startCycleCounter();
  #endif
/*
  switch(index) {
    case 0:
      byte memory[][8] = {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 1:
      byte memory[][8] = {{1, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 2:
      byte memory[][8] = {{2, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 3:
      byte memory[][8] = {{3, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 4:
      byte memory[][8] = {{4, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 5:
      byte memory[][8] = {{5, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 6:
      byte memory[][8] = {{6, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 7:
      byte memory[][8] = {{7, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 8:
      byte memory[][8] = {{8, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 9:
      byte memory[][8] = {{9, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 10:
      byte memory[][8] = {{10, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 11:
      byte memory[][8] = {{11, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 12:
      byte memory[][8] = {{12, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 13:
      byte memory[][8] = {{13, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 14:
      byte memory[][8] = {{14, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 15:
      byte memory[][8] = {{15, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 16:
      byte memory[][8] = {{16, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 17:
      byte memory[][8] = {{17, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 18:
      byte memory[][8] = {{18, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 19:
      byte memory[][8] = {{19, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 20:
      byte memory[][8] = {{20, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 21:
      byte memory[][8] = {{21, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 22:
      byte memory[][8] = {{22, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 23:
      byte memory[][8] = {{23, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 24:
      byte memory[][8] = {{24, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 25:
      byte memory[][8] = {{25, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 26:
      byte memory[][8] = {{26, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 27:
      byte memory[][8] = {{27, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 28:
      byte memory[][8] = {{28, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 29:
      byte memory[][8] = {{29, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 30:
      byte memory[][8] = {{30, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 31:
      byte memory[][8] = {{31, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
    case 32:
      byte memory[][8] = {{32, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}};
      break;
  }
*/

  //memcpy(byteBuffer, memory, 8);
  
  #if LOG_CYCLE_COUNTER == 1
  stopCycleCounter();
  #endif
  
  /*
  for (int i = 0; i < 2048; i++) {
    for (int j = 0; j < 8; j++) {
      Serial.print(foo[i][j]);
      Serial.print(", ");
    }  
  }
  */
  
  Serial.println("");
}

void loadPicture(byte byteBuffer[][8], int index) {
  
  /*
  Notes :
  Enbiron 130 cycles pour copier 1 octet parmis 1 avec memcpy dans bytebuffer.
  Environ 400 cycles pour copier 8 octets parmis 64 avec memcpy dans bytebuffer.
  Environ 800 cycles pour copier 64 octets parmis 64 avec memcpy dans bytebuffer.
  Environ 1600 cycles pour copier 128 octets parmis 128 avec memcpy dans bytebuffer.
  Environ 3200 cycles pour copier 8 octets parmis 512 avec memcpy dans bytebuffer.
  Environ 3600 cycles pour copier 64 octets parmis 512 avec memcpy dans bytebuffer.
  
  Idées :
  Charger en SRAM des morceaux de 64 bytes => 400 cycles.
  On charge les 64 premiers bytes, puis on précharge les 64 suivants dans la loop en tache de fond.
  Dés que l'on a plus besoin de 64 premiers bytes, on passe au 64 suivants déjà préchargés et on lance le préchargement de 64 nouveaux.
  
  Du coup il faut définir des blocs de 64 bytes à initialiser en SRAM lors du préchargement.
  Pour une image de 256 * 8 bytes, il faut donc 32 blocs de 64 bytes.
  */
  
  
  #if LOG_CYCLE_COUNTER == 1
  Serial.print("test ");
  startCycleCounter();
  stopCycleCounter();
  
  Serial.print("load8bytesInSram ");
  startCycleCounter();
  #endif
      
  // 8x8x8 bytes = 512 bytes
  byte foo[][8] = {
    {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0},
   /* {1, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0},
    {2, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0},
    {3, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0},
    {4, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0},
    {5, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0},
    {6, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0},
    {7, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0},*/
  };
  
  memcpy(byteBuffer, foo[index * 8], 8);
  
  #if LOG_CYCLE_COUNTER == 1
  stopCycleCounter();
  #endif
  
  /*
  for (int i = 0; i < 2048; i++) {
    for (int j = 0; j < 8; j++) {
      Serial.print(foo[i][j]);
      Serial.print(", ");
    }  
  }
  */
  
  Serial.println("");
}

